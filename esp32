#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h"
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ArduinoJson.h>

//////////////// WIFI //////////////////
const char* ssid = "Rohan";
const char* password = "Rohan123";

// Toggle between LOCAL and CLOUD
#define USE_CLOUD true 

String localURL = "http://10.121.7.118:5000/predict";
String cloudURL = "https://stress-monitoring-system-using-ppg-sensor.onrender.com/predict";

String serverURL = USE_CLOUD ? cloudURL : localURL;

//////////////// OLED //////////////////
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

//////////////// SENSOR //////////////////
MAX30105 sensor;

//////////////// VARIABLES //////////////////
float bpm = 0;
float hrv = 0;
String stressLevel = "IDLE";
String warningMsg = "";
String currentDisplayMode = "STRESS";
bool isSensorActive = true;
int lastHttpCode = 0;
String lastError = "";

long lastBeatTime = 0;
long prevRR = 0;
bool fingerDetected = false;
long lastSensorCheck = 0;

//////////////// BPM AVERAGING //////////////////
#define RATE_SIZE 10
float bpmBuffer[RATE_SIZE];
int bpmIndex = 0;
bool bpmReady = false;

//////////////// HRV SETTINGS //////////////////
#define HRV_SIZE 15
long rrDiffSq[HRV_SIZE];
int hrvIndex = 0;
bool hrvReady = false;

//////////////// TIMING //////////////////
unsigned long lastSendTime = 0;
unsigned long lastDisplayTime = 0;
unsigned long sendInterval = 10000; 

//////////////////////////////////////////////////////

void setupSensor() {
  if (!sensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("MAX30105 NOT FOUND");
    display.clearDisplay();
    display.setCursor(0, 10);
    display.setTextSize(1);
    display.println("SENSOR ERROR!");
    display.println("Check Wires/VCC");
    display.display();
    return;
  }
  // Increased ledBrightness to 100 for better skin penetration
  // sampleAverage 4, ledMode 2 (Red+IR), sampleRate 100, pulseWidth 411, adcRange 4096
  sensor.setup(100, 4, 2, 100, 411, 4096); 
  sensor.setPulseAmplitudeRed(0x1F); // Increased Red LED for better visibility
  sensor.setPulseAmplitudeIR(0x32);  // High IR LED for better heart signal
}

void connectWiFi() {
  display.clearDisplay();
  display.setCursor(0, 10);
  display.println("Connecting WiFi...");
  display.display();

  WiFi.begin(ssid, password);
  int retry = 0;
  while (WiFi.status() != WL_CONNECTED && retry < 20) {
    delay(500);
    Serial.print(".");
    retry++;
  }

  display.clearDisplay();
  display.setCursor(0, 10);
  if (WiFi.status() == WL_CONNECTED) {
    display.println("WiFi Connected!");
    display.println(WiFi.localIP());
  } else {
    display.println("WiFi Failed");
  }
  display.display();
  delay(1000);
}

void sendToServer() {
  if (WiFi.status() != WL_CONNECTED) return;

  WiFiClientSecure *client = nullptr;
  HTTPClient http;
  http.setTimeout(25000); // 25s for Render

  if (serverURL.startsWith("https")) {
    client = new WiFiClientSecure;
    client->setInsecure();
    http.begin(*client, serverURL);
  } else {
    http.begin(serverURL);
  }

  http.addHeader("Content-Type", "application/json");

  StaticJsonDocument<200> doc;
  if (fingerDetected && bpm > 0) {
    doc["bpm"] = (int)bpm;
    doc["hrv"] = (int)hrv;
    doc["spo2"] = 98;
    doc["respiration"] = 16;
  } else {
    doc["bpm"] = 0;
    doc["hrv"] = 0;
    doc["spo2"] = 0;
    doc["respiration"] = 0;
  }

  String body;
  serializeJson(doc, body);

  Serial.print("Sending to: "); Serial.println(serverURL);
  int code = http.POST(body);
  lastHttpCode = code;
  
  if (code > 0) {
    lastError = "OK";
    String payload = http.getString();
    Serial.print("HTTP Code: "); Serial.println(code);
    Serial.println("Response: " + payload);
    
    StaticJsonDocument<512> recvDoc;
    if (!deserializeJson(recvDoc, payload)) {
      if (recvDoc.containsKey("stress")) stressLevel = recvDoc["stress"].as<String>();
      if (recvDoc.containsKey("warning")) warningMsg = recvDoc["warning"].as<String>();
      if (recvDoc.containsKey("send_interval")) sendInterval = recvDoc["send_interval"].as<int>();
      if (recvDoc.containsKey("display_mode")) currentDisplayMode = recvDoc["display_mode"].as<String>();
      if (recvDoc.containsKey("is_sensor_active")) isSensorActive = recvDoc["is_sensor_active"].as<bool>();
      
      if (recvDoc["recalibrate"] == true) {
        Serial.println("Recalibrating...");
        bpmReady = false; bpmIndex = 0; hrvReady = false; hrvIndex = 0;
        bpm = 0; hrv = 0;
        setupSensor();
      }
    }
  } else {
    lastError = http.errorToString(code);
    Serial.print("HTTP Error: "); Serial.println(lastError);
  }
  
  http.end();
  if (client) {
    delete client; // Free heap memory
  }
}

void calculateHRV(long rr) {
  if (rr < 400 || rr > 1500) return; 

  if (prevRR > 0) {
    long diff = abs(rr - prevRR);
    Serial.print("RR Diff: "); Serial.println(diff);

    if (diff < 200) { // Tightened back to 200ms for medical validity
      rrDiffSq[hrvIndex++] = diff * diff;
      if (hrvIndex >= HRV_SIZE) { hrvIndex = 0; hrvReady = true; }
      
      int count = hrvReady ? HRV_SIZE : hrvIndex;
      if (count >= 5) { // Increased min count to 5 for smoother start
        float sum = 0;
        for (int i = 0; i < count; i++) sum += rrDiffSq[i];
        hrv = sqrt(sum / count);
        Serial.print("HRV Updated: "); Serial.println(hrv);
      }
    } else {
      Serial.println("Diff out of range (>200)");
    }
  }
  prevRR = rr;
}

void readSensor() {
  // Always sample - do not stop based on server flag to prevent "turned off" state
  long irValue = sensor.getIR();
  Serial.print("IR: "); Serial.println(irValue);

  if (irValue < 5000) { // Lowered threshold for weak signals
    fingerDetected = false;
    return;
  }

  fingerDetected = true;

  if (checkForBeat(irValue)) {
    long currentTime = millis();
    long rr = currentTime - lastBeatTime;
    lastBeatTime = currentTime;

    if (rr > 370 && rr < 1500) {
      float instantBpm = 60000.0 / rr;
      bpmBuffer[bpmIndex++] = instantBpm;
      if (bpmIndex >= RATE_SIZE) { bpmIndex = 0; bpmReady = true; }
      int count = bpmReady ? RATE_SIZE : bpmIndex;
      float sum = 0;
      for (int i = 0; i < count; i++) sum += bpmBuffer[i];
      bpm = sum / count;
      calculateHRV(rr);
    }
  }
}

void updateDisplay() {
  display.clearDisplay();
  display.setTextColor(WHITE);
  
  if (currentDisplayMode == "STRESS") {
    display.setTextSize(1);
    display.setCursor(0, 0);
    display.println("STRESS MONITOR");
    display.drawLine(0, 9, 128, 9, WHITE);
    display.setCursor(100, 0);
    if (fingerDetected) display.print("LIVE"); else display.print("HOLD");

    display.setCursor(0, 15);
    display.print("BPM: "); display.setTextSize(2); display.print((int)bpm);
    display.setTextSize(1); display.print("   HRV: "); display.setTextSize(2); display.println((int)hrv);
    display.setTextSize(1);
    display.setCursor(0, 38);
    display.print("STRESS: "); display.setTextSize(2); display.println(stressLevel);
  } 
  else if (currentDisplayMode == "BPM") {
    display.setCursor(0, 0);
    display.println("HEART RATE");
    display.drawLine(0, 9, 128, 9, WHITE);
    display.setCursor(0, 20);
    display.setTextSize(4);
    display.print((int)bpm);
    display.setTextSize(2);
    display.print(" BPM");
  }
  else if (currentDisplayMode == "SPO2") {
    display.setCursor(0, 0);
    display.println("SPO2 & RESP");
    display.drawLine(0, 9, 128, 9, WHITE);
    display.setCursor(0, 20);
    display.setTextSize(2);
    display.print("SPO2: "); display.setTextSize(3); display.print("98%");
    display.setCursor(0, 45);
    display.setTextSize(2);
    display.print("RESP: "); display.setTextSize(3); display.print("16");
  }
  else if (currentDisplayMode == "IDLE") {
    display.setCursor(0, 0);
    display.setTextSize(1);
    display.println("DEBUG STATUS");
    display.drawLine(0, 9, 128, 9, WHITE);
    display.setCursor(0, 15);
    display.print("WiFi: "); display.println(WiFi.status() == WL_CONNECTED ? "OK" : "ERR");
    display.print("HTTP: "); display.println(lastHttpCode);
    display.print("ERR: "); display.println(lastError);
  }

  // Footer / Timer (Always show small at the bottom)
  int timeLeft = (int)(sendInterval - (millis() - lastSendTime)) / 1000;
  if (timeLeft < 0) timeLeft = 0;
  display.setTextSize(1);
  display.setCursor(0, 56);
  if (lastHttpCode != 200 && lastHttpCode != 0) {
    display.print("Net Err: "); display.print(lastHttpCode);
  }
  else {
    display.print("Sync in: "); display.print(timeLeft); display.print("s");
  }
  display.display();
}

void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);
  Wire.setClock(400000); // Standard Fast I2C

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) for (;;);
  connectWiFi();
  setupSensor();
  lastSendTime = millis();
  lastSensorCheck = millis();
}

void loop() {
  sensor.check(); 
  readSensor();

  // Recovery: Only re-init if the IR value is logically impossible or sensor hangs
  // Reset lastSensorCheck in the loop to prevent timeout during normal operation
  if (sensor.getIR() < 100) { // Sensor either dead or disconnected
      if (millis() - lastSensorCheck > 15000) { 
        Serial.println("Re-initializing sensor...");
        setupSensor();
        lastSensorCheck = millis();
      }
  } else {
      lastSensorCheck = millis(); // Sensor is alive (even if no finger)
  }

  if (millis() - lastSendTime > sendInterval) {
    lastSendTime = millis();
    sendToServer();
    sensor.check();
    lastBeatTime = millis();
    lastSensorCheck = millis();
  }

  // Throttle display to 5 FPS to reduce I2C bus traffic
  if (millis() - lastDisplayTime > 200) {
    lastDisplayTime = millis();
    updateDisplay();
  }
}
